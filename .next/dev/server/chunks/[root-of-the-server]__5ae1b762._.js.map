{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient }\n\nexport const prisma =\n  globalForPrisma.prisma ||\n  new PrismaClient()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,sMAAY;AAElB,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/grid.ts"],"sourcesContent":["export interface GridPoint {\n    lat: number;\n    lng: number;\n    id?: string;\n}\n\nexport type GridShape = 'SQUARE' | 'CIRCLE' | 'ZIP' | 'SMART';\n\nexport function generateGrid(\n    centerLat: number,\n    centerLng: number,\n    radiusKm: number,\n    gridSize: number,\n    shape: GridShape = 'SQUARE'\n): GridPoint[] {\n    if (shape === 'CIRCLE') {\n        return generateCircleGrid(centerLat, centerLng, radiusKm, gridSize);\n    }\n\n    if (shape === 'ZIP') {\n        return generateZipGrid(centerLat, centerLng, radiusKm, gridSize);\n    }\n\n    if (shape === 'SMART') {\n        return generateSmartGrid(centerLat, centerLng, radiusKm);\n    }\n\n    const points: GridPoint[] = [];\n    const latDelta = radiusKm / 111.111;\n    const lngDelta = radiusKm / (111.111 * Math.cos(centerLat * (Math.PI / 180)));\n\n    const startLat = centerLat - latDelta;\n    const startLng = centerLng - lngDelta;\n\n    const latStep = (latDelta * 2) / (gridSize - 1);\n    const lngStep = (lngDelta * 2) / (gridSize - 1);\n\n    for (let i = 0; i < gridSize; i++) {\n        for (let j = 0; j < gridSize; j++) {\n            points.push({\n                lat: startLat + i * latStep,\n                lng: startLng + j * lngStep,\n                id: `sq-${i}-${j}`\n            });\n        }\n    }\n\n    return points;\n}\n\nfunction generateCircleGrid(centerLat: number, centerLng: number, radiusKm: number, gridSize: number): GridPoint[] {\n    const points: GridPoint[] = [];\n    points.push({ lat: centerLat, lng: centerLng, id: 'center' }); // Always include center\n\n    const rings = Math.floor(gridSize / 2);\n    if (rings < 1) return points;\n\n    for (let r = 1; r <= rings; r++) {\n        const ringRadius = (radiusKm * r) / rings;\n        const numPoints = r * 6; // Hexagonal-ish distribution\n\n        for (let i = 0; i < numPoints; i++) {\n            const angle = (i * 360) / numPoints;\n            const bearing = angle * (Math.PI / 180);\n\n            // Haversine-ish approximate offset\n            const latOffset = (ringRadius / 111.111) * Math.cos(bearing);\n            const lngOffset = (ringRadius / (111.111 * Math.cos(centerLat * (Math.PI / 180)))) * Math.sin(bearing);\n\n            points.push({\n                lat: centerLat + latOffset,\n                lng: centerLng + lngOffset,\n                id: `circle-${r}-${i}`\n            });\n        }\n    }\n\n    return points;\n}\n\nfunction generateZipGrid(centerLat: number, centerLng: number, radiusKm: number, gridSize: number): GridPoint[] {\n    const points: GridPoint[] = [];\n    // For Zip mode, we cluster pins semi-randomly but concentrated in sub-sectors\n    // In a real app, this would query a zip-code boundary API\n    const sectors = 4;\n    const pointsPerSector = Math.ceil((gridSize * gridSize) / sectors);\n\n    for (let s = 0; s < sectors; s++) {\n        const sectorAngle = (s * 360) / sectors;\n        const bearing = sectorAngle * (Math.PI / 180);\n\n        // Sector center\n        const sLat = centerLat + (radiusKm * 0.6 / 111.111) * Math.cos(bearing);\n        const sLng = centerLng + (radiusKm * 0.6 / (111.111 * Math.cos(centerLat * (Math.PI / 180)))) * Math.sin(bearing);\n\n        for (let i = 0; i < pointsPerSector; i++) {\n            const jitter = 0.2 * radiusKm;\n            const jLat = (Math.random() - 0.5) * jitter / 111.111;\n            const jLng = (Math.random() - 0.5) * jitter / (111.111 * Math.cos(sLat * (Math.PI / 180)));\n\n            points.push({\n                lat: sLat + jLat,\n                lng: sLng + jLng,\n                id: `zip-${s}-${i}`\n            });\n        }\n    }\n\n    return points;\n}\n\nfunction generateSmartGrid(centerLat: number, centerLng: number, radiusKm: number): GridPoint[] {\n    const points: GridPoint[] = [];\n    const R = 6371; // Earth's radius in km\n\n    // Smart grid focused on center\n    points.push({ lat: centerLat, lng: centerLng, id: 'smart-center' });\n\n    // Ring configuration: [distanceFromCenterInKm, pointSpacingInKm]\n    // We scale this based on the total radius requested\n    const ringConfigs = [\n        { dist: 0.15, spacing: 0.3 },\n        { dist: 0.4, spacing: 0.5 },\n        { dist: 0.8, spacing: 0.8 },\n        { dist: 1.5, spacing: 1.2 },\n        { dist: 3.0, spacing: 2.0 },\n        { dist: 6.0, spacing: 4.0 },\n        { dist: 12.0, spacing: 8.0 }\n    ];\n\n    ringConfigs.forEach((ring, ringIdx) => {\n        // Adjust ring distance relative to the requested radius\n        // If radius is 3km, we don't want points at 12km\n        if (ring.dist * (radiusKm / 3) > radiusKm && ringIdx > 1) return;\n\n        const actualDist = ring.dist * (radiusKm / 3);\n        const actualSpacing = ring.spacing * (radiusKm / 3);\n\n        const circumference = 2 * Math.PI * actualDist;\n        const numPoints = Math.max(3, Math.floor(circumference / actualSpacing));\n        const angleStep = (2 * Math.PI) / numPoints;\n\n        for (let i = 0; i < numPoints; i++) {\n            const angle = angleStep * i;\n            // Haversine approximation for small distances\n            const latOffset = (actualDist / 111.111) * Math.cos(angle);\n            const lngOffset = (actualDist / (111.111 * Math.cos(centerLat * (Math.PI / 180)))) * Math.sin(angle);\n\n            points.push({\n                lat: centerLat + latOffset,\n                lng: centerLng + lngOffset,\n                id: `smart-${ringIdx}-${i}`\n            });\n        }\n    });\n\n    return points;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 211, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/scraper.ts"],"sourcesContent":["import { chromium, BrowserContext, Page } from 'playwright';\n\nexport interface ScrapeResult {\n    name: string;\n    rating?: number;\n    reviews?: number;\n    address?: string;\n    url?: string;\n    rank: number;\n}\n\nexport async function scrapeGMB(page: Page, keyword: string, lat: number, lng: number): Promise<ScrapeResult[]> {\n    try {\n        console.log(`[Scraper] Starting scrape for: ${keyword} at ${lat}, ${lng}`);\n\n        // Navigate with a more realistic timeout and wait strategy\n        // Google Maps takes a long time to reach networkidle, so we use domcontentloaded\n        await page.goto(`https://www.google.com/maps/search/${encodeURIComponent(keyword)}/@${lat},${lng},14z/`, {\n            waitUntil: 'domcontentloaded',\n            timeout: 60000,\n        });\n\n        // Wait for results to load - use multiple common selectors\n        try {\n            await page.waitForFunction(() => {\n                return !!(document.querySelector('[role=\"article\"]') ||\n                    document.querySelector('.qBF1Pd') ||\n                    document.querySelector('[role=\"feed\"]'));\n            }, { timeout: 20000 });\n        } catch (e) {\n            console.log('[Scraper] Warning: Standard result selectors not found, trying fallback extraction anyway.');\n        }\n\n        // Mimic human scrolling behavior\n        for (let i = 0; i < 3; i++) {\n            await page.evaluate(() => {\n                const scrollable = document.querySelector('[role=\"feed\"]') || document.body;\n                scrollable.scrollBy(0, 800);\n            });\n            await page.waitForTimeout(1000 + Math.random() * 1000);\n        }\n\n        // Extract results with robust, multiple-path selectors\n        // We use a self-invoking function string to avoid any transpilation artifacts like __name\n        const results: ScrapeResult[] = await page.evaluate(() => {\n            const extracted: any[] = [];\n\n            // Priority 1: Articles with specific roles\n            let items = Array.from(document.querySelectorAll('div[role=\"article\"]'));\n\n            // Priority 2: Links that look like place profiles\n            if (items.length === 0) {\n                const links = Array.from(document.querySelectorAll('a[href*=\"/maps/place/\"]'));\n                items = links.map(l => l.closest('div') || l).filter(Boolean) as Element[];\n            }\n\n            const seenNames = new Set();\n\n            items.forEach((item) => {\n                if (extracted.length >= 20) return;\n\n                let name = '';\n                const ariaLabel = item.getAttribute('aria-label');\n                if (ariaLabel && !ariaLabel.includes('stars') && ariaLabel.length > 2) {\n                    name = ariaLabel;\n                }\n\n                // Strategy B: Specific class signatures\n                if (!name) {\n                    const nameEl = item.querySelector('.fontHeadlineSmall, .qBF1Pd, [role=\"heading\"]');\n                    name = nameEl?.textContent?.trim() || '';\n                }\n\n                if (!name || name.length < 2) return;\n                name = name.split(' Â· ')[0].replace(/\\. \\d+$/, '').trim();\n\n                if (seenNames.has(name.toLowerCase())) return;\n                seenNames.add(name.toLowerCase());\n\n                // URL/Link Extraction\n                const linkEl = item.querySelector('a[href*=\"/maps/place/\"]') || item.closest('a[href*=\"/maps/place/\"]');\n                const url = linkEl ? (linkEl as HTMLAnchorElement).href : '';\n\n                // Rating & Reviews extraction\n                const ratingEl = item.querySelector('[role=\"img\"][aria-label*=\"stars\"]');\n                const ratingLabel = ratingEl?.getAttribute('aria-label') || '';\n                const ratingMatch = ratingLabel.match(/([0-9.]+)\\s+stars/);\n                const rating = ratingMatch ? parseFloat(ratingMatch[1]) : undefined;\n\n                const reviewsMatch = ratingLabel.match(/\\(([\\d,]+)\\)/) || ratingLabel.match(/([\\d,]+)\\s+reviews/);\n                const reviews = reviewsMatch ? parseInt(reviewsMatch[1].replace(/,/g, '')) : 0;\n\n                const text = (item as HTMLElement).innerText || '';\n                const lines = text.split('\\n');\n                const address = lines.find(l => l.match(/\\d+/) && l !== name && l.length > 5) || '';\n\n                extracted.push({\n                    name,\n                    rating,\n                    reviews,\n                    address: address.trim(),\n                    url,\n                    rank: extracted.length + 1\n                });\n            });\n\n            return extracted;\n        });\n\n        console.log(`[Scraper] Successfully extracted ${results.length} results.`);\n        return results;\n\n    } catch (error) {\n        console.error(`[Scraper] Error scraping ${lat},${lng}:`, error);\n        return [];\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 307, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/scanner.ts"],"sourcesContent":["import { prisma } from './prisma';\nimport { generateGrid } from './grid';\nimport { scrapeGMB } from './scraper';\nimport { chromium } from 'playwright';\n\nexport async function runScan(scanId: string) {\n    const scan = await prisma.scan.findUnique({\n        where: { id: scanId },\n    });\n\n    if (!scan) throw new Error('Scan not found');\n\n    await prisma.scan.update({\n        where: { id: scanId },\n        data: { status: 'RUNNING' },\n    });\n\n    const points = scan.customPoints\n        ? JSON.parse(scan.customPoints)\n        : generateGrid(scan.centerLat, scan.centerLng, scan.radius, scan.gridSize, scan.shape as any);\n\n    // Fetch enabled proxies and global settings\n    const [enabledProxies, proxySetting] = await Promise.all([\n        prisma.proxy.findMany({ where: { enabled: true } }),\n        prisma.globalSetting.findUnique({ where: { key: 'useSystemProxy' } })\n    ]);\n\n    const useSystemProxy = proxySetting ? proxySetting.value === 'true' : true;\n\n    const launchOptions: any = { headless: true };\n\n    // If not using system proxy and we have proxies in the pool\n    if (!useSystemProxy && enabledProxies.length > 0) {\n        // Simple random proxy selection for load balancing\n        const p = enabledProxies[Math.floor(Math.random() * enabledProxies.length)];\n        launchOptions.proxy = {\n            server: `${p.host}:${p.port}`,\n            username: p.username || undefined,\n            password: p.password || undefined,\n        };\n        console.log(`[Scanner] Using proxy routing: ${p.host}:${p.port}`);\n    } else {\n        console.log(`[Scanner] Using Direct System Connection (no proxy)`);\n    }\n\n    const browser = await chromium.launch(launchOptions);\n    const context = await browser.newContext({\n        viewport: { width: 1280, height: 800 },\n        userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n    });\n\n    // Grant geolocation permissions globally for the context\n    await context.grantPermissions(['geolocation']);\n\n    const page = await context.newPage();\n\n    try {\n        for (const point of points) {\n            // Check if scan has been stopped\n            const currentScan = await prisma.scan.findUnique({\n                where: { id: scanId },\n                select: { status: true }\n            });\n\n            if (!currentScan || currentScan.status === 'STOPPED') {\n                console.log(`Scan ${scanId} was stopped.`);\n                break;\n            }\n\n            console.log(`Scraping point: ${point.lat}, ${point.lng}`);\n\n            // Set geolocation for THIS specific point\n            await context.setGeolocation({ latitude: point.lat, longitude: point.lng });\n\n            const results = await scrapeGMB(page, scan.keyword, point.lat, point.lng);\n\n            let rank = null;\n            let targetName = null;\n\n            if (scan.businessName) {\n                const match = results.find(r => r.name.toLowerCase().includes(scan.businessName!.toLowerCase()));\n                if (match) {\n                    rank = match.rank;\n                    targetName = match.name;\n                }\n            }\n\n            await prisma.result.create({\n                data: {\n                    scanId: scan.id,\n                    lat: point.lat,\n                    lng: point.lng,\n                    topResults: JSON.stringify(results),\n                    rank,\n                    targetName\n                },\n            });\n\n            // Delay between points to avoid detection (slightly reduced since we are reusing context)\n            await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));\n        }\n\n        // Calculate NEXT RUN if recurring\n        let nextRun = null;\n        if (scan.frequency === 'DAILY') {\n            nextRun = new Date(Date.now() + 24 * 60 * 60 * 1000);\n        } else if (scan.frequency === 'WEEKLY') {\n            nextRun = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);\n        }\n\n        // Check for rank changes and create alerts\n        if (scan.businessName) {\n            const previousScan = await prisma.scan.findFirst({\n                where: {\n                    keyword: scan.keyword,\n                    businessName: scan.businessName,\n                    status: 'COMPLETED',\n                    id: { not: scanId }\n                },\n                orderBy: { createdAt: 'desc' },\n                include: { results: true }\n            });\n\n            if (previousScan) {\n                const currentResults = await prisma.result.findMany({ where: { scanId } });\n                const currentAvg = currentResults.reduce((acc, r) => acc + (r.rank || 21), 0) / currentResults.length;\n                const previousAvg = previousScan.results.reduce((acc, r) => acc + (r.rank || 21), 0) / previousScan.results.length;\n\n                const diff = previousAvg - currentAvg; // Positive means improvement (rank decreased)\n                if (Math.abs(diff) >= 0.5) {\n                    await prisma.alert.create({\n                        data: {\n                            type: diff > 0 ? 'RANK_UP' : 'RANK_DOWN',\n                            message: `${scan.businessName} rank ${diff > 0 ? 'improved' : 'dropped'} by ${Math.abs(diff).toFixed(1)} points for \"${scan.keyword}\"`,\n                            scanId: scan.id\n                        }\n                    });\n                }\n            }\n        }\n\n        await prisma.scan.update({\n            where: { id: scanId },\n            data: {\n                status: 'COMPLETED',\n                nextRun\n            },\n        });\n\n    } catch (error) {\n        console.error(`[Scanner] Critical failure in scan ${scanId}:`, error);\n        await prisma.scan.update({\n            where: { id: scanId },\n            data: { status: 'FAILED' },\n        });\n\n        await prisma.alert.create({\n            data: {\n                type: 'SCAN_ERROR',\n                message: `Scan failed for \"${scan.keyword}\": ${error instanceof Error ? error.message : String(error)}`,\n                scanId: scanId\n            }\n        });\n    } finally {\n        await browser.close();\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 508, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/app/api/scans/route.ts"],"sourcesContent":["import { prisma } from '@/lib/prisma';\nimport { NextResponse } from 'next/server';\nimport { runScan } from '@/lib/scanner';\n\nexport async function GET() {\n    try {\n        const scans = await prisma.scan.findMany({\n            orderBy: { createdAt: 'desc' },\n        });\n        return NextResponse.json({ scans });\n    } catch (error) {\n        console.error('Scans GET error:', error);\n        return NextResponse.json({ scans: [] });\n    }\n}\n\nexport async function POST(req: Request) {\n    try {\n        const {\n            keyword,\n            radius,\n            gridSize,\n            frequency,\n            businessName,\n            shape,\n            customPoints,\n            lat,\n            lng\n        } = await req.json();\n\n        // Use provided coordinates or default to Chicago (Mock)\n        const centerLat = lat || 41.8781;\n        const centerLng = lng || -87.6298;\n\n        const scan = await prisma.scan.create({\n            data: {\n                keyword,\n                centerLat,\n                centerLng,\n                radius: parseFloat(radius) || 5,\n                gridSize: parseInt(gridSize) || 3,\n                shape: shape || 'SQUARE',\n                customPoints: customPoints ? JSON.stringify(customPoints) : null,\n                frequency: frequency || 'ONCE',\n                businessName: businessName || undefined,\n                status: 'PENDING',\n            },\n        });\n\n        // Start scan in background\n        runScan(scan.id).catch(console.error);\n\n        return NextResponse.json(scan);\n    } catch (error) {\n        console.error('Scan creation CRITICAL error:', error);\n        if (error instanceof Error) {\n            console.error('Error message:', error.message);\n            console.error('Error stack:', error.stack);\n        }\n        return NextResponse.json({ error: 'Failed to create scan', details: String(error) }, { status: 500 });\n    }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;;;;;AAEO,eAAe;IAClB,IAAI;QACA,MAAM,QAAQ,MAAM,gIAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;YACrC,SAAS;gBAAE,WAAW;YAAO;QACjC;QACA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE;QAAM;IACrC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,oBAAoB;QAClC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,EAAE;QAAC;IACzC;AACJ;AAEO,eAAe,KAAK,GAAY;IACnC,IAAI;QACA,MAAM,EACF,OAAO,EACP,MAAM,EACN,QAAQ,EACR,SAAS,EACT,YAAY,EACZ,KAAK,EACL,YAAY,EACZ,GAAG,EACH,GAAG,EACN,GAAG,MAAM,IAAI,IAAI;QAElB,wDAAwD;QACxD,MAAM,YAAY,OAAO;QACzB,MAAM,YAAY,OAAO,CAAC;QAE1B,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YAClC,MAAM;gBACF;gBACA;gBACA;gBACA,QAAQ,WAAW,WAAW;gBAC9B,UAAU,SAAS,aAAa;gBAChC,OAAO,SAAS;gBAChB,cAAc,eAAe,KAAK,SAAS,CAAC,gBAAgB;gBAC5D,WAAW,aAAa;gBACxB,cAAc,gBAAgB;gBAC9B,QAAQ;YACZ;QACJ;QAEA,2BAA2B;QAC3B,IAAA,kIAAO,EAAC,KAAK,EAAE,EAAE,KAAK,CAAC,QAAQ,KAAK;QAEpC,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,IAAI,iBAAiB,OAAO;YACxB,QAAQ,KAAK,CAAC,kBAAkB,MAAM,OAAO;YAC7C,QAAQ,KAAK,CAAC,gBAAgB,MAAM,KAAK;QAC7C;QACA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;YAAyB,SAAS,OAAO;QAAO,GAAG;YAAE,QAAQ;QAAI;IACvG;AACJ"}}]
}