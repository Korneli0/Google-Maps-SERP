{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient }\n\nexport const prisma =\n  globalForPrisma.prisma ||\n  new PrismaClient()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,sMAAY;AAElB,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/grid.ts"],"sourcesContent":["export interface GridPoint {\n    lat: number;\n    lng: number;\n}\n\nexport function generateGrid(centerLat: number, centerLng: number, radiusKm: number, gridSize: number): GridPoint[] {\n    const points: GridPoint[] = [];\n\n    // 1 degree of latitude is ~111.111 km\n    const latDelta = radiusKm / 111.111;\n    // 1 degree of longitude is ~111.111 * cos(lat) km\n    const lngDelta = radiusKm / (111.111 * Math.cos(centerLat * (Math.PI / 180)));\n\n    const startLat = centerLat - latDelta;\n    const startLng = centerLng - lngDelta;\n\n    const latStep = (latDelta * 2) / (gridSize - 1);\n    const lngStep = (lngDelta * 2) / (gridSize - 1);\n\n    for (let i = 0; i < gridSize; i++) {\n        for (let j = 0; j < gridSize; j++) {\n            points.push({\n                lat: startLat + i * latStep,\n                lng: startLng + j * lngStep,\n            });\n        }\n    }\n\n    return points;\n}\n"],"names":[],"mappings":";;;;AAKO,SAAS,aAAa,SAAiB,EAAE,SAAiB,EAAE,QAAgB,EAAE,QAAgB;IACjG,MAAM,SAAsB,EAAE;IAE9B,sCAAsC;IACtC,MAAM,WAAW,WAAW;IAC5B,kDAAkD;IAClD,MAAM,WAAW,WAAW,CAAC,UAAU,KAAK,GAAG,CAAC,YAAY,CAAC,KAAK,EAAE,GAAG,GAAG,EAAE;IAE5E,MAAM,WAAW,YAAY;IAC7B,MAAM,WAAW,YAAY;IAE7B,MAAM,UAAU,AAAC,WAAW,IAAK,CAAC,WAAW,CAAC;IAC9C,MAAM,UAAU,AAAC,WAAW,IAAK,CAAC,WAAW,CAAC;IAE9C,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,IAAK;QAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,IAAK;YAC/B,OAAO,IAAI,CAAC;gBACR,KAAK,WAAW,IAAI;gBACpB,KAAK,WAAW,IAAI;YACxB;QACJ;IACJ;IAEA,OAAO;AACX"}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/scraper.ts"],"sourcesContent":["import { chromium, BrowserContext, Page } from 'playwright';\n\nexport interface ScrapeResult {\n    name: string;\n    rating?: number;\n    reviews?: number;\n    address?: string;\n    rank: number;\n}\n\nexport async function scrapeGMB(page: Page, keyword: string, lat: number, lng: number): Promise<ScrapeResult[]> {\n    try {\n        console.log(`[Scraper] Starting scrape for: ${keyword} at ${lat}, ${lng}`);\n\n        // Navigate with a more realistic timeout and wait strategy\n        // Google Maps takes a long time to reach networkidle, so we use domcontentloaded\n        await page.goto(`https://www.google.com/maps/search/${encodeURIComponent(keyword)}/@${lat},${lng},14z/`, {\n            waitUntil: 'domcontentloaded',\n            timeout: 60000,\n        });\n\n        // Wait for results to load - use multiple common selectors\n        try {\n            await page.waitForFunction(() => {\n                return !!(document.querySelector('[role=\"article\"]') ||\n                    document.querySelector('.qBF1Pd') ||\n                    document.querySelector('[role=\"feed\"]'));\n            }, { timeout: 20000 });\n        } catch (e) {\n            console.log('[Scraper] Warning: Standard result selectors not found, trying fallback extraction anyway.');\n        }\n\n        // Mimic human scrolling behavior\n        for (let i = 0; i < 3; i++) {\n            await page.evaluate(() => {\n                const scrollable = document.querySelector('[role=\"feed\"]') || document.body;\n                scrollable.scrollBy(0, 800);\n            });\n            await page.waitForTimeout(1000 + Math.random() * 1000);\n        }\n\n        // Extract results with robust, multiple-path selectors\n        // We use a self-invoking function string to avoid any transpilation artifacts like __name\n        const results: ScrapeResult[] = await page.evaluate(() => {\n            const extracted: any[] = [];\n\n            // Priority 1: Articles with specific roles\n            let items = Array.from(document.querySelectorAll('div[role=\"article\"]'));\n\n            // Priority 2: Links that look like place profiles\n            if (items.length === 0) {\n                const links = Array.from(document.querySelectorAll('a[href*=\"/maps/place/\"]'));\n                items = links.map(l => l.closest('div') || l).filter(Boolean) as Element[];\n            }\n\n            const seenNames = new Set();\n\n            items.forEach((item) => {\n                if (extracted.length >= 20) return;\n\n                let name = '';\n                const ariaLabel = item.getAttribute('aria-label');\n                if (ariaLabel && !ariaLabel.includes('stars') && ariaLabel.length > 2) {\n                    name = ariaLabel;\n                }\n\n                if (!name) {\n                    const nameEl = item.querySelector('.fontHeadlineSmall, .qBF1Pd, [role=\"heading\"]');\n                    name = nameEl?.textContent?.trim() || '';\n                }\n\n                if (!name || name.length < 2) return;\n                name = name.split(' Â· ')[0].replace(/\\. \\d+$/, '').trim();\n\n                if (seenNames.has(name.toLowerCase())) return;\n                seenNames.add(name.toLowerCase());\n\n                const ratingEl = item.querySelector('[role=\"img\"][aria-label*=\"stars\"]');\n                const ratingLabel = ratingEl?.getAttribute('aria-label') || '';\n                const ratingMatch = ratingLabel.match(/([0-9.]+)\\s+stars/);\n                const rating = ratingMatch ? parseFloat(ratingMatch[1]) : undefined;\n\n                const text = (item as HTMLElement).innerText || '';\n                const lines = text.split('\\n');\n                const address = lines.find(l => l.match(/\\d+/) && l !== name && l.length > 5) || '';\n\n                extracted.push({\n                    name,\n                    rating,\n                    reviews: 0,\n                    address: address.trim(),\n                    rank: extracted.length + 1\n                });\n            });\n\n            return extracted;\n        });\n\n        console.log(`[Scraper] Successfully extracted ${results.length} results.`);\n        return results;\n\n    } catch (error) {\n        console.error(`[Scraper] Error scraping ${lat},${lng}:`, error);\n        return [];\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 175, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/scanner.ts"],"sourcesContent":["import { prisma } from './prisma';\nimport { generateGrid } from './grid';\nimport { scrapeGMB } from './scraper';\nimport { chromium } from 'playwright';\n\nexport async function runScan(scanId: string) {\n    const scan = await prisma.scan.findUnique({\n        where: { id: scanId },\n    });\n\n    if (!scan) throw new Error('Scan not found');\n\n    await prisma.scan.update({\n        where: { id: scanId },\n        data: { status: 'RUNNING' },\n    });\n\n    const points = generateGrid(scan.centerLat, scan.centerLng, scan.radius, scan.gridSize);\n\n    // Launch browser ONCE for the entire scan\n    const browser = await chromium.launch({ headless: true });\n    const context = await browser.newContext({\n        viewport: { width: 1280, height: 800 },\n        userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n    });\n\n    // Grant geolocation permissions globally for the context\n    await context.grantPermissions(['geolocation']);\n\n    const page = await context.newPage();\n\n    try {\n        for (const point of points) {\n            // Check if scan has been stopped\n            const currentScan = await prisma.scan.findUnique({\n                where: { id: scanId },\n                select: { status: true }\n            });\n\n            if (!currentScan || currentScan.status === 'STOPPED') {\n                console.log(`Scan ${scanId} was stopped.`);\n                break;\n            }\n\n            console.log(`Scraping point: ${point.lat}, ${point.lng}`);\n\n            // Set geolocation for THIS specific point\n            await context.setGeolocation({ latitude: point.lat, longitude: point.lng });\n\n            const results = await scrapeGMB(page, scan.keyword, point.lat, point.lng);\n\n            let rank = null;\n            let targetName = null;\n\n            if (scan.businessName) {\n                const match = results.find(r => r.name.toLowerCase().includes(scan.businessName!.toLowerCase()));\n                if (match) {\n                    rank = match.rank;\n                    targetName = match.name;\n                }\n            }\n\n            await prisma.result.create({\n                data: {\n                    scanId: scan.id,\n                    lat: point.lat,\n                    lng: point.lng,\n                    topResults: JSON.stringify(results),\n                    rank,\n                    targetName\n                },\n            });\n\n            // Delay between points to avoid detection (slightly reduced since we are reusing context)\n            await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));\n        }\n\n        await prisma.scan.update({\n            where: { id: scanId },\n            data: { status: 'COMPLETED' },\n        });\n\n    } catch (error) {\n        console.error(`[Scanner] Critical failure in scan ${scanId}:`, error);\n        await prisma.scan.update({\n            where: { id: scanId },\n            data: { status: 'FAILED' },\n        });\n    } finally {\n        await browser.close();\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;;;;;AAEO,eAAe,QAAQ,MAAc;IACxC,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACtC,OAAO;YAAE,IAAI;QAAO;IACxB;IAEA,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM;IAE3B,MAAM,gIAAM,CAAC,IAAI,CAAC,MAAM,CAAC;QACrB,OAAO;YAAE,IAAI;QAAO;QACpB,MAAM;YAAE,QAAQ;QAAU;IAC9B;IAEA,MAAM,SAAS,IAAA,oIAAY,EAAC,KAAK,SAAS,EAAE,KAAK,SAAS,EAAE,KAAK,MAAM,EAAE,KAAK,QAAQ;IAEtF,0CAA0C;IAC1C,MAAM,UAAU,MAAM,iLAAQ,CAAC,MAAM,CAAC;QAAE,UAAU;IAAK;IACvD,MAAM,UAAU,MAAM,QAAQ,UAAU,CAAC;QACrC,UAAU;YAAE,OAAO;YAAM,QAAQ;QAAI;QACrC,WAAW;IACf;IAEA,yDAAyD;IACzD,MAAM,QAAQ,gBAAgB,CAAC;QAAC;KAAc;IAE9C,MAAM,OAAO,MAAM,QAAQ,OAAO;IAElC,IAAI;QACA,KAAK,MAAM,SAAS,OAAQ;YACxB,iCAAiC;YACjC,MAAM,cAAc,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;gBAC7C,OAAO;oBAAE,IAAI;gBAAO;gBACpB,QAAQ;oBAAE,QAAQ;gBAAK;YAC3B;YAEA,IAAI,CAAC,eAAe,YAAY,MAAM,KAAK,WAAW;gBAClD,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,OAAO,aAAa,CAAC;gBACzC;YACJ;YAEA,QAAQ,GAAG,CAAC,CAAC,gBAAgB,EAAE,MAAM,GAAG,CAAC,EAAE,EAAE,MAAM,GAAG,EAAE;YAExD,0CAA0C;YAC1C,MAAM,QAAQ,cAAc,CAAC;gBAAE,UAAU,MAAM,GAAG;gBAAE,WAAW,MAAM,GAAG;YAAC;YAEzE,MAAM,UAAU,MAAM,IAAA,oIAAS,EAAC,MAAM,KAAK,OAAO,EAAE,MAAM,GAAG,EAAE,MAAM,GAAG;YAExE,IAAI,OAAO;YACX,IAAI,aAAa;YAEjB,IAAI,KAAK,YAAY,EAAE;gBACnB,MAAM,QAAQ,QAAQ,IAAI,CAAC,CAAA,IAAK,EAAE,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,KAAK,YAAY,CAAE,WAAW;gBAC5F,IAAI,OAAO;oBACP,OAAO,MAAM,IAAI;oBACjB,aAAa,MAAM,IAAI;gBAC3B;YACJ;YAEA,MAAM,gIAAM,CAAC,MAAM,CAAC,MAAM,CAAC;gBACvB,MAAM;oBACF,QAAQ,KAAK,EAAE;oBACf,KAAK,MAAM,GAAG;oBACd,KAAK,MAAM,GAAG;oBACd,YAAY,KAAK,SAAS,CAAC;oBAC3B;oBACA;gBACJ;YACJ;YAEA,0FAA0F;YAC1F,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS,OAAO,KAAK,MAAM,KAAK;QAC5E;QAEA,MAAM,gIAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YACrB,OAAO;gBAAE,IAAI;YAAO;YACpB,MAAM;gBAAE,QAAQ;YAAY;QAChC;IAEJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,CAAC,mCAAmC,EAAE,OAAO,CAAC,CAAC,EAAE;QAC/D,MAAM,gIAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YACrB,OAAO;gBAAE,IAAI;YAAO;YACpB,MAAM;gBAAE,QAAQ;YAAS;QAC7B;IACJ,SAAU;QACN,MAAM,QAAQ,KAAK;IACvB;AACJ"}},
    {"offset": {"line": 296, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/app/api/scans/route.ts"],"sourcesContent":["import { prisma } from '@/lib/prisma';\nimport { NextResponse } from 'next/server';\nimport { runScan } from '@/lib/scanner';\n\nexport async function GET() {\n    try {\n        const scans = await prisma.scan.findMany({\n            orderBy: { createdAt: 'desc' },\n        });\n        return NextResponse.json({ scans });\n    } catch (error) {\n        console.error('Scans GET error:', error);\n        return NextResponse.json({ scans: [] });\n    }\n}\n\nexport async function POST(req: Request) {\n    try {\n        const { keyword, address, radius, gridSize, frequency, businessName } = await req.json();\n\n        // MOCKING Geocoding - In production, use Google Maps Geocoding API\n        const centerLat = 41.8781;\n        const centerLng = -87.6298;\n\n        const scan = await prisma.scan.create({\n            data: {\n                keyword,\n                centerLat,\n                centerLng,\n                radius: parseFloat(radius) || 5,\n                gridSize: parseInt(gridSize) || 3,\n                frequency: frequency || 'ONCE',\n                businessName: businessName || undefined,\n                status: 'PENDING',\n            },\n        });\n\n        // Start scan in background\n        runScan(scan.id).catch(console.error);\n\n        return NextResponse.json(scan);\n    } catch (error) {\n        console.error('Scan creation CRITICAL error:', error);\n        if (error instanceof Error) {\n            console.error('Error message:', error.message);\n            console.error('Error stack:', error.stack);\n        }\n        return NextResponse.json({ error: 'Failed to create scan', details: String(error) }, { status: 500 });\n    }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;;;;;AAEO,eAAe;IAClB,IAAI;QACA,MAAM,QAAQ,MAAM,gIAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;YACrC,SAAS;gBAAE,WAAW;YAAO;QACjC;QACA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE;QAAM;IACrC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,oBAAoB;QAClC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,EAAE;QAAC;IACzC;AACJ;AAEO,eAAe,KAAK,GAAY;IACnC,IAAI;QACA,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,YAAY,EAAE,GAAG,MAAM,IAAI,IAAI;QAEtF,mEAAmE;QACnE,MAAM,YAAY;QAClB,MAAM,YAAY,CAAC;QAEnB,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YAClC,MAAM;gBACF;gBACA;gBACA;gBACA,QAAQ,WAAW,WAAW;gBAC9B,UAAU,SAAS,aAAa;gBAChC,WAAW,aAAa;gBACxB,cAAc,gBAAgB;gBAC9B,QAAQ;YACZ;QACJ;QAEA,2BAA2B;QAC3B,IAAA,kIAAO,EAAC,KAAK,EAAE,EAAE,KAAK,CAAC,QAAQ,KAAK;QAEpC,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,IAAI,iBAAiB,OAAO;YACxB,QAAQ,KAAK,CAAC,kBAAkB,MAAM,OAAO;YAC7C,QAAQ,KAAK,CAAC,gBAAgB,MAAM,KAAK;QAC7C;QACA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;YAAyB,SAAS,OAAO;QAAO,GAAG;YAAE,QAAQ;QAAI;IACvG;AACJ"}}]
}